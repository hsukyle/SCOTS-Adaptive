\hypertarget{classscots_1_1ReachAndStay}{}\section{scots\+:\+:Reach\+And\+Stay$<$ X\+\_\+type, U\+\_\+type $>$ Class Template Reference}
\label{classscots_1_1ReachAndStay}\index{scots\+::\+Reach\+And\+Stay$<$ X\+\_\+type, U\+\_\+type $>$@{scots\+::\+Reach\+And\+Stay$<$ X\+\_\+type, U\+\_\+type $>$}}


A class (derived from base \hyperlink{classscots_1_1Adaptive}{Adaptive}) that does adaptive multiscale abstraction-\/based synthesis for a reach-\/and-\/stay specification.  




{\ttfamily \#include $<$Reach\+And\+Stay.\+hh$>$}

Inheritance diagram for scots\+:\+:Reach\+And\+Stay$<$ X\+\_\+type, U\+\_\+type $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{classscots_1_1ReachAndStay}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classscots_1_1ReachAndStay_ad7b8e64bead2b77ba81d793180b66416}{Reach\+And\+Stay} (\hyperlink{classscots_1_1System}{System} $\ast$system, double $\ast$eta\+Ratio, double tau\+Ratio, int nint, int num\+Abs, int read\+XX, int read\+Abs, char $\ast$log\+File)
\item 
\hyperlink{classscots_1_1ReachAndStay_a03d6d40d05fc810d88965b3f7a78c2fe}{$\sim$\+Reach\+And\+Stay} ()
\item 
{\footnotesize template$<$class G\+\_\+type , class I\+\_\+type $>$ }\\void \hyperlink{classscots_1_1ReachAndStay_a8615d9a4050bbb186a38fe0e3ae97c69}{reach\+And\+Stay} (G\+\_\+type addG, I\+\_\+type addI, int start\+Abs, int min\+To\+Go\+Coarser, int min\+To\+Be\+Valid, int early\+Break)
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
\subsubsection*{template$<$class X\+\_\+type, class U\+\_\+type$>$\newline
class scots\+::\+Reach\+And\+Stay$<$ X\+\_\+type, U\+\_\+type $>$}

A class (derived from base \hyperlink{classscots_1_1Adaptive}{Adaptive}) that does adaptive multiscale abstraction-\/based synthesis for a reach-\/and-\/stay specification. 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classscots_1_1ReachAndStay_ad7b8e64bead2b77ba81d793180b66416}\label{classscots_1_1ReachAndStay_ad7b8e64bead2b77ba81d793180b66416}} 
\index{scots\+::\+Reach\+And\+Stay@{scots\+::\+Reach\+And\+Stay}!Reach\+And\+Stay@{Reach\+And\+Stay}}
\index{Reach\+And\+Stay@{Reach\+And\+Stay}!scots\+::\+Reach\+And\+Stay@{scots\+::\+Reach\+And\+Stay}}
\subsubsection{\texorpdfstring{Reach\+And\+Stay()}{ReachAndStay()}}
{\footnotesize\ttfamily template$<$class X\+\_\+type , class U\+\_\+type $>$ \\
\hyperlink{classscots_1_1ReachAndStay}{scots\+::\+Reach\+And\+Stay}$<$ X\+\_\+type, U\+\_\+type $>$\+::\hyperlink{classscots_1_1ReachAndStay}{Reach\+And\+Stay} (\begin{DoxyParamCaption}\item[{\hyperlink{classscots_1_1System}{System} $\ast$}]{system,  }\item[{double $\ast$}]{eta\+Ratio,  }\item[{double}]{tau\+Ratio,  }\item[{int}]{nint,  }\item[{int}]{num\+Abs,  }\item[{int}]{read\+XX,  }\item[{int}]{read\+Abs,  }\item[{char $\ast$}]{log\+File }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Constructor for a \hyperlink{classscots_1_1ReachAndStay}{Reach\+And\+Stay} object. \mbox{\Hypertarget{classscots_1_1ReachAndStay_a03d6d40d05fc810d88965b3f7a78c2fe}\label{classscots_1_1ReachAndStay_a03d6d40d05fc810d88965b3f7a78c2fe}} 
\index{scots\+::\+Reach\+And\+Stay@{scots\+::\+Reach\+And\+Stay}!````~Reach\+And\+Stay@{$\sim$\+Reach\+And\+Stay}}
\index{````~Reach\+And\+Stay@{$\sim$\+Reach\+And\+Stay}!scots\+::\+Reach\+And\+Stay@{scots\+::\+Reach\+And\+Stay}}
\subsubsection{\texorpdfstring{$\sim$\+Reach\+And\+Stay()}{~ReachAndStay()}}
{\footnotesize\ttfamily template$<$class X\+\_\+type , class U\+\_\+type $>$ \\
\hyperlink{classscots_1_1ReachAndStay}{scots\+::\+Reach\+And\+Stay}$<$ X\+\_\+type, U\+\_\+type $>$\+::$\sim$\hyperlink{classscots_1_1ReachAndStay}{Reach\+And\+Stay} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Deconstructor for a \hyperlink{classscots_1_1ReachAndStay}{Reach\+And\+Stay} object. 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classscots_1_1ReachAndStay_a8615d9a4050bbb186a38fe0e3ae97c69}\label{classscots_1_1ReachAndStay_a8615d9a4050bbb186a38fe0e3ae97c69}} 
\index{scots\+::\+Reach\+And\+Stay@{scots\+::\+Reach\+And\+Stay}!reach\+And\+Stay@{reach\+And\+Stay}}
\index{reach\+And\+Stay@{reach\+And\+Stay}!scots\+::\+Reach\+And\+Stay@{scots\+::\+Reach\+And\+Stay}}
\subsubsection{\texorpdfstring{reach\+And\+Stay()}{reachAndStay()}}
{\footnotesize\ttfamily template$<$class X\+\_\+type , class U\+\_\+type $>$ \\
template$<$class G\+\_\+type , class I\+\_\+type $>$ \\
void \hyperlink{classscots_1_1ReachAndStay}{scots\+::\+Reach\+And\+Stay}$<$ X\+\_\+type, U\+\_\+type $>$\+::reach\+And\+Stay (\begin{DoxyParamCaption}\item[{G\+\_\+type}]{addG,  }\item[{I\+\_\+type}]{addI,  }\item[{int}]{start\+Abs,  }\item[{int}]{min\+To\+Go\+Coarser,  }\item[{int}]{min\+To\+Be\+Valid,  }\item[{int}]{early\+Break }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Writes a series of controllers that satisfies a reach-\/and-\/stay specification. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em addG} & Function pointer specifying the points that should be added to the goal set. \\
\hline
\mbox{\tt in}  & {\em addI} & Function pointer specifying the points that should be added to the initial set. \\
\hline
\mbox{\tt in}  & {\em start\+Abs} & 0-\/index of the abstraction to start with. \\
\hline
\mbox{\tt in}  & {\em min\+To\+Go\+Coarser} & Minimum number of growing fixed point iterations needed before an attempt to go to a coarser abstraction. \\
\hline
\mbox{\tt in}  & {\em min\+To\+Be\+Valid} & Minimum number of growing fixed point iterations needed before a controller is declared valid. \\
\hline
\mbox{\tt in}  & {\em early\+Break} & If 1, the synthesis ends as soon as I meets the domain of C. \\
\hline
\end{DoxyParams}


The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/kylehsu/\+S\+C\+O\+T\+S-\/\+Adaptive/bdd/\hyperlink{ReachAndStay_8hh}{Reach\+And\+Stay.\+hh}\end{DoxyCompactItemize}
