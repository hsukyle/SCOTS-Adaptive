\hypertarget{classscots_1_1Reach}{}\section{scots\+:\+:Reach$<$ X\+\_\+type, U\+\_\+type $>$ Class Template Reference}
\label{classscots_1_1Reach}\index{scots\+::\+Reach$<$ X\+\_\+type, U\+\_\+type $>$@{scots\+::\+Reach$<$ X\+\_\+type, U\+\_\+type $>$}}


A class (derived from base \hyperlink{classscots_1_1Adaptive}{Adaptive}) that does adaptive multiscale abstraction-\/based synthesis for a reach specification.  




{\ttfamily \#include $<$Reach.\+hh$>$}

Inheritance diagram for scots\+:\+:Reach$<$ X\+\_\+type, U\+\_\+type $>$\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{classscots_1_1Reach}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
\hyperlink{classscots_1_1Reach_ac61b7e746e55013c48de47eb3dc00ff7}{Reach} (int dimX, double $\ast$lbX, double $\ast$ubX, double $\ast$etaX, double tau, int dimU, double $\ast$lbU, double $\ast$ubU, double $\ast$etaU, double $\ast$eta\+Ratio, double tau\+Ratio, int nint, int num\+Abs, int read\+XX, int read\+Abs, char $\ast$log\+File)
\item 
\hyperlink{classscots_1_1Reach_a05425187c9015158f5495904c34342d0}{$\sim$\+Reach} ()
\item 
void \hyperlink{classscots_1_1Reach_a6787ba675345efb35d5b5dcd720cf389}{mu} (int min\+To\+Go\+Coarser, int min\+To\+Be\+Valid, int early\+Break, int verbose, int $\ast$cur\+Abs, int $\ast$iter, int $\ast$just\+Coarsed, int $\ast$iter\+Cur\+Abs, int $\ast$reached, int $\ast$stop)
\item 
int \hyperlink{classscots_1_1Reach_aae2c35919866a8235f822542a4bb3dfe}{reach} (int start\+Abs, int min\+To\+Go\+Coarser, int min\+To\+Be\+Valid, int early\+Break, int verbose=1)
\item 
{\footnotesize template$<$class G\+\_\+type , class I\+\_\+type $>$ }\\void \hyperlink{classscots_1_1Reach_ad49c77293343ad0ce4f36c9deee45f00}{initialize\+Reach} (G\+\_\+type addG, I\+\_\+type addI)
\item 
void \hyperlink{classscots_1_1Reach_ada9bf5083703b737976effb85de28c4b}{save\+CZ} (int cur\+Abs)
\item 
void \hyperlink{classscots_1_1Reach_ab9c39fa2834a0a8f08abe48838ae1c41}{save\+Verify} ()
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
vector$<$ Symbolic\+Set $\ast$ $>$ \hyperlink{classscots_1_1Reach_af3fd5ddf192d97ec5dc650ad57e6c485}{Gs\+\_\+}
\item 
vector$<$ Symbolic\+Set $\ast$ $>$ \hyperlink{classscots_1_1Reach_a3366767e4a2edbb8c683e0a74a709b10}{Is\+\_\+}
\item 
vector$<$ Symbolic\+Set $\ast$ $>$ \hyperlink{classscots_1_1Reach_a2f484ac1e7bd5a451b409c373149369c}{valid\+Zs\+\_\+}
\item 
vector$<$ Symbolic\+Set $\ast$ $>$ \hyperlink{classscots_1_1Reach_ade8c2425a8ff0cc7d7ed017412b6aa29}{valid\+Cs\+\_\+}
\item 
vector$<$ Symbolic\+Set $\ast$ $>$ \hyperlink{classscots_1_1Reach_a42e41806d2c3308e41de9b21afae2206}{final\+Cs\+\_\+}
\item 
vector$<$ Symbolic\+Set $\ast$ $>$ \hyperlink{classscots_1_1Reach_ae607710b3da219ec741f8609f870bafd}{final\+Zs\+\_\+}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\subsubsection*{template$<$class X\+\_\+type, class U\+\_\+type$>$\newline
class scots\+::\+Reach$<$ X\+\_\+type, U\+\_\+type $>$}

A class (derived from base \hyperlink{classscots_1_1Adaptive}{Adaptive}) that does adaptive multiscale abstraction-\/based synthesis for a reach specification. 

\subsection{Constructor \& Destructor Documentation}
\mbox{\Hypertarget{classscots_1_1Reach_ac61b7e746e55013c48de47eb3dc00ff7}\label{classscots_1_1Reach_ac61b7e746e55013c48de47eb3dc00ff7}} 
\index{scots\+::\+Reach@{scots\+::\+Reach}!Reach@{Reach}}
\index{Reach@{Reach}!scots\+::\+Reach@{scots\+::\+Reach}}
\subsubsection{\texorpdfstring{Reach()}{Reach()}}
{\footnotesize\ttfamily template$<$class X\+\_\+type , class U\+\_\+type $>$ \\
\hyperlink{classscots_1_1Reach}{scots\+::\+Reach}$<$ X\+\_\+type, U\+\_\+type $>$\+::\hyperlink{classscots_1_1Reach}{Reach} (\begin{DoxyParamCaption}\item[{int}]{dimX,  }\item[{double $\ast$}]{lbX,  }\item[{double $\ast$}]{ubX,  }\item[{double $\ast$}]{etaX,  }\item[{double}]{tau,  }\item[{int}]{dimU,  }\item[{double $\ast$}]{lbU,  }\item[{double $\ast$}]{ubU,  }\item[{double $\ast$}]{etaU,  }\item[{double $\ast$}]{eta\+Ratio,  }\item[{double}]{tau\+Ratio,  }\item[{int}]{nint,  }\item[{int}]{num\+Abs,  }\item[{int}]{read\+XX,  }\item[{int}]{read\+Abs,  }\item[{char $\ast$}]{log\+File }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Constructor for a \hyperlink{classscots_1_1Reach}{Reach} object. \mbox{\Hypertarget{classscots_1_1Reach_a05425187c9015158f5495904c34342d0}\label{classscots_1_1Reach_a05425187c9015158f5495904c34342d0}} 
\index{scots\+::\+Reach@{scots\+::\+Reach}!````~Reach@{$\sim$\+Reach}}
\index{````~Reach@{$\sim$\+Reach}!scots\+::\+Reach@{scots\+::\+Reach}}
\subsubsection{\texorpdfstring{$\sim$\+Reach()}{~Reach()}}
{\footnotesize\ttfamily template$<$class X\+\_\+type , class U\+\_\+type $>$ \\
\hyperlink{classscots_1_1Reach}{scots\+::\+Reach}$<$ X\+\_\+type, U\+\_\+type $>$\+::$\sim$\hyperlink{classscots_1_1Reach}{Reach} (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Deconstructor for a \hyperlink{classscots_1_1Reach}{Reach} object. 

\subsection{Member Function Documentation}
\mbox{\Hypertarget{classscots_1_1Reach_ad49c77293343ad0ce4f36c9deee45f00}\label{classscots_1_1Reach_ad49c77293343ad0ce4f36c9deee45f00}} 
\index{scots\+::\+Reach@{scots\+::\+Reach}!initialize\+Reach@{initialize\+Reach}}
\index{initialize\+Reach@{initialize\+Reach}!scots\+::\+Reach@{scots\+::\+Reach}}
\subsubsection{\texorpdfstring{initialize\+Reach()}{initializeReach()}}
{\footnotesize\ttfamily template$<$class X\+\_\+type , class U\+\_\+type $>$ \\
template$<$class G\+\_\+type , class I\+\_\+type $>$ \\
void \hyperlink{classscots_1_1Reach}{scots\+::\+Reach}$<$ X\+\_\+type, U\+\_\+type $>$\+::initialize\+Reach (\begin{DoxyParamCaption}\item[{G\+\_\+type}]{addG,  }\item[{I\+\_\+type}]{addI }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Initializes objects specific to the following specifications\+: always-\/eventually, reach-\/while-\/avoid. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em addG} & Function pointer specifying the points that should be added to the goal set. \\
\hline
\mbox{\tt in}  & {\em addI} & Function pointer specifying the points that should be added to the initial set. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classscots_1_1Reach_a6787ba675345efb35d5b5dcd720cf389}\label{classscots_1_1Reach_a6787ba675345efb35d5b5dcd720cf389}} 
\index{scots\+::\+Reach@{scots\+::\+Reach}!mu@{mu}}
\index{mu@{mu}!scots\+::\+Reach@{scots\+::\+Reach}}
\subsubsection{\texorpdfstring{mu()}{mu()}}
{\footnotesize\ttfamily template$<$class X\+\_\+type , class U\+\_\+type $>$ \\
void \hyperlink{classscots_1_1Reach}{scots\+::\+Reach}$<$ X\+\_\+type, U\+\_\+type $>$\+::mu (\begin{DoxyParamCaption}\item[{int}]{min\+To\+Go\+Coarser,  }\item[{int}]{min\+To\+Be\+Valid,  }\item[{int}]{early\+Break,  }\item[{int}]{verbose,  }\item[{int $\ast$}]{cur\+Abs,  }\item[{int $\ast$}]{iter,  }\item[{int $\ast$}]{just\+Coarsed,  }\item[{int $\ast$}]{iter\+Cur\+Abs,  }\item[{int $\ast$}]{reached,  }\item[{int $\ast$}]{stop }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

One iteration in an adaptive minimal fixed point. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em min\+To\+Go\+Coarser} & Minimum number of iterations at an abstraction (not coarsest) before attemping to project to the next coarser abstraction. \\
\hline
\mbox{\tt in}  & {\em min\+To\+Be\+Valid} & Minimum number of iterations at an abstraction (not finest) after having gone coarser before a controller is declared valid and saved as a backup. \\
\hline
\mbox{\tt in}  & {\em early\+Break} & Whether the fixed point should end as soon as a strategy exists for the initial state. \\
\hline
\mbox{\tt in}  & {\em verbose} & Whether messages detailing the steps of the algorithm should be printed to the log file. \\
\hline
\mbox{\tt in,out}  & {\em cur\+Abs} & 0-\/index of the abstraction under consideration for the current iteration. \\
\hline
\mbox{\tt in,out}  & {\em iter} & Counter for the total number of iterations of the minimal fixed point. \\
\hline
\mbox{\tt in,out}  & {\em just\+Coarsed} & Status of the abstraction under consideration. \\
\hline
\mbox{\tt in,out}  & {\em iter\+Cur\+Abs} & Counter for the consecutive number of iterations for the current abstraction. \\
\hline
\mbox{\tt in,out}  & {\em reached} & Whether the initial state has been declared winning. \\
\hline
\mbox{\tt in,out}  & {\em stop} & Whether the fixed point should end. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classscots_1_1Reach_aae2c35919866a8235f822542a4bb3dfe}\label{classscots_1_1Reach_aae2c35919866a8235f822542a4bb3dfe}} 
\index{scots\+::\+Reach@{scots\+::\+Reach}!reach@{reach}}
\index{reach@{reach}!scots\+::\+Reach@{scots\+::\+Reach}}
\subsubsection{\texorpdfstring{reach()}{reach()}}
{\footnotesize\ttfamily template$<$class X\+\_\+type , class U\+\_\+type $>$ \\
int \hyperlink{classscots_1_1Reach}{scots\+::\+Reach}$<$ X\+\_\+type, U\+\_\+type $>$\+::reach (\begin{DoxyParamCaption}\item[{int}]{start\+Abs,  }\item[{int}]{min\+To\+Go\+Coarser,  }\item[{int}]{min\+To\+Be\+Valid,  }\item[{int}]{early\+Break,  }\item[{int}]{verbose = {\ttfamily 1} }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Writes, should they exist, a sequence of controller and controller domain B\+D\+Ds to directories \textquotesingle{}C\textquotesingle{} and \textquotesingle{}Z\textquotesingle{} respectively that satisfy the reachability specification. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em start\+Abs} & 0-\/index of the abstraction to start with. \\
\hline
\mbox{\tt in}  & {\em min\+To\+Go\+Coarser} & Minimum number of growing fixed point iterations needed before an attempt to go to a coarser abstraction. \\
\hline
\mbox{\tt in}  & {\em min\+To\+Be\+Valid} & Minimum number of growing fixed point iterations needed before a controller is declared valid. \\
\hline
\mbox{\tt in}  & {\em early\+Break} & If 1, the synthesis ends as soon as I meets the domain of C. \\
\hline
\mbox{\tt in}  & {\em verbose} & If 1, prints additional information during synthesis to the log file.\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
1 if controller(s) satisfying specification is/are synthesized; 0 otherwise. 
\end{DoxyReturn}
\mbox{\Hypertarget{classscots_1_1Reach_ada9bf5083703b737976effb85de28c4b}\label{classscots_1_1Reach_ada9bf5083703b737976effb85de28c4b}} 
\index{scots\+::\+Reach@{scots\+::\+Reach}!save\+CZ@{save\+CZ}}
\index{save\+CZ@{save\+CZ}!scots\+::\+Reach@{scots\+::\+Reach}}
\subsubsection{\texorpdfstring{save\+C\+Z()}{saveCZ()}}
{\footnotesize\ttfamily template$<$class X\+\_\+type , class U\+\_\+type $>$ \\
void \hyperlink{classscots_1_1Reach}{scots\+::\+Reach}$<$ X\+\_\+type, U\+\_\+type $>$\+::save\+CZ (\begin{DoxyParamCaption}\item[{int}]{cur\+Abs }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Saves a snapshot of a controller and its domain into the sequence of final controllers and controller domains. 
\begin{DoxyParams}[1]{Parameters}
\mbox{\tt in}  & {\em cur\+Abs} & 0-\/index of the abstraction which the controller and controller domain that should be saved belong to. \\
\hline
\end{DoxyParams}
\mbox{\Hypertarget{classscots_1_1Reach_ab9c39fa2834a0a8f08abe48838ae1c41}\label{classscots_1_1Reach_ab9c39fa2834a0a8f08abe48838ae1c41}} 
\index{scots\+::\+Reach@{scots\+::\+Reach}!save\+Verify@{save\+Verify}}
\index{save\+Verify@{save\+Verify}!scots\+::\+Reach@{scots\+::\+Reach}}
\subsubsection{\texorpdfstring{save\+Verify()}{saveVerify()}}
{\footnotesize\ttfamily template$<$class X\+\_\+type , class U\+\_\+type $>$ \\
void \hyperlink{classscots_1_1Reach}{scots\+::\+Reach}$<$ X\+\_\+type, U\+\_\+type $>$\+::save\+Verify (\begin{DoxyParamCaption}{ }\end{DoxyParamCaption})\hspace{0.3cm}{\ttfamily [inline]}}

Saves and prints to log file some information related to the reachability/always-\/eventually specification. 

\subsection{Member Data Documentation}
\mbox{\Hypertarget{classscots_1_1Reach_a42e41806d2c3308e41de9b21afae2206}\label{classscots_1_1Reach_a42e41806d2c3308e41de9b21afae2206}} 
\index{scots\+::\+Reach@{scots\+::\+Reach}!final\+Cs\+\_\+@{final\+Cs\+\_\+}}
\index{final\+Cs\+\_\+@{final\+Cs\+\_\+}!scots\+::\+Reach@{scots\+::\+Reach}}
\subsubsection{\texorpdfstring{final\+Cs\+\_\+}{finalCs\_}}
{\footnotesize\ttfamily template$<$class X\+\_\+type , class U\+\_\+type $>$ \\
vector$<$Symbolic\+Set$\ast$$>$ \hyperlink{classscots_1_1Reach}{scots\+::\+Reach}$<$ X\+\_\+type, U\+\_\+type $>$\+::final\+Cs\+\_\+}

Sequence of controllers that satisfy the specification. \mbox{\Hypertarget{classscots_1_1Reach_ae607710b3da219ec741f8609f870bafd}\label{classscots_1_1Reach_ae607710b3da219ec741f8609f870bafd}} 
\index{scots\+::\+Reach@{scots\+::\+Reach}!final\+Zs\+\_\+@{final\+Zs\+\_\+}}
\index{final\+Zs\+\_\+@{final\+Zs\+\_\+}!scots\+::\+Reach@{scots\+::\+Reach}}
\subsubsection{\texorpdfstring{final\+Zs\+\_\+}{finalZs\_}}
{\footnotesize\ttfamily template$<$class X\+\_\+type , class U\+\_\+type $>$ \\
vector$<$Symbolic\+Set$\ast$$>$ \hyperlink{classscots_1_1Reach}{scots\+::\+Reach}$<$ X\+\_\+type, U\+\_\+type $>$\+::final\+Zs\+\_\+}

Sequence of domains of final\+Cs\+\_\+. \mbox{\Hypertarget{classscots_1_1Reach_af3fd5ddf192d97ec5dc650ad57e6c485}\label{classscots_1_1Reach_af3fd5ddf192d97ec5dc650ad57e6c485}} 
\index{scots\+::\+Reach@{scots\+::\+Reach}!Gs\+\_\+@{Gs\+\_\+}}
\index{Gs\+\_\+@{Gs\+\_\+}!scots\+::\+Reach@{scots\+::\+Reach}}
\subsubsection{\texorpdfstring{Gs\+\_\+}{Gs\_}}
{\footnotesize\ttfamily template$<$class X\+\_\+type , class U\+\_\+type $>$ \\
vector$<$Symbolic\+Set$\ast$$>$ \hyperlink{classscots_1_1Reach}{scots\+::\+Reach}$<$ X\+\_\+type, U\+\_\+type $>$\+::Gs\+\_\+}

Instance of $\ast$\+Xs\+\_\+\mbox{[}i\mbox{]} containing goal states. \mbox{\Hypertarget{classscots_1_1Reach_a3366767e4a2edbb8c683e0a74a709b10}\label{classscots_1_1Reach_a3366767e4a2edbb8c683e0a74a709b10}} 
\index{scots\+::\+Reach@{scots\+::\+Reach}!Is\+\_\+@{Is\+\_\+}}
\index{Is\+\_\+@{Is\+\_\+}!scots\+::\+Reach@{scots\+::\+Reach}}
\subsubsection{\texorpdfstring{Is\+\_\+}{Is\_}}
{\footnotesize\ttfamily template$<$class X\+\_\+type , class U\+\_\+type $>$ \\
vector$<$Symbolic\+Set$\ast$$>$ \hyperlink{classscots_1_1Reach}{scots\+::\+Reach}$<$ X\+\_\+type, U\+\_\+type $>$\+::Is\+\_\+}

Instance of $\ast$\+Xs\+\_\+\mbox{[}i\mbox{]} containing initial states. \mbox{\Hypertarget{classscots_1_1Reach_ade8c2425a8ff0cc7d7ed017412b6aa29}\label{classscots_1_1Reach_ade8c2425a8ff0cc7d7ed017412b6aa29}} 
\index{scots\+::\+Reach@{scots\+::\+Reach}!valid\+Cs\+\_\+@{valid\+Cs\+\_\+}}
\index{valid\+Cs\+\_\+@{valid\+Cs\+\_\+}!scots\+::\+Reach@{scots\+::\+Reach}}
\subsubsection{\texorpdfstring{valid\+Cs\+\_\+}{validCs\_}}
{\footnotesize\ttfamily template$<$class X\+\_\+type , class U\+\_\+type $>$ \\
vector$<$Symbolic\+Set$\ast$$>$ \hyperlink{classscots_1_1Reach}{scots\+::\+Reach}$<$ X\+\_\+type, U\+\_\+type $>$\+::valid\+Cs\+\_\+}

Controllers that act as savepoints. \mbox{\Hypertarget{classscots_1_1Reach_a2f484ac1e7bd5a451b409c373149369c}\label{classscots_1_1Reach_a2f484ac1e7bd5a451b409c373149369c}} 
\index{scots\+::\+Reach@{scots\+::\+Reach}!valid\+Zs\+\_\+@{valid\+Zs\+\_\+}}
\index{valid\+Zs\+\_\+@{valid\+Zs\+\_\+}!scots\+::\+Reach@{scots\+::\+Reach}}
\subsubsection{\texorpdfstring{valid\+Zs\+\_\+}{validZs\_}}
{\footnotesize\ttfamily template$<$class X\+\_\+type , class U\+\_\+type $>$ \\
vector$<$Symbolic\+Set$\ast$$>$ \hyperlink{classscots_1_1Reach}{scots\+::\+Reach}$<$ X\+\_\+type, U\+\_\+type $>$\+::valid\+Zs\+\_\+}

Contains winning states that act as savepoints. 

The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
/home/kylehsu/\+S\+C\+O\+T\+S-\/\+Adaptive/bdd/\hyperlink{Reach_8hh}{Reach.\+hh}\end{DoxyCompactItemize}
